<!doctype html><html lang=en-US><!doctype html><html><head><title>RIP flatMapGroupsWithState</title>
<meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="llms killed my best friend"><meta name=keywords content="Technology,Code,Program,Linux,"><meta name=author content="Nick Karpov"><meta property="og:title" content="RIP flatMapGroupsWithState"><meta property="og:description" content="You'd be crazy not to try the new transformWithState API for your Spark Streaming jobs with arbitrary state"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://nickkarpov.com/2025/transform-with-state/"><meta property="og:image" content="https://nickkarpov.com/2025/transform-with-state/image.png"><meta property="article:published_time" content="2025-02-27T01:00:00Z"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/main.min.8a7c15ecafd33cb478712d698109fc39e0e0e2a4817fdb59d42f20484af07a08.css integrity="sha256-inwV7K/TPLR4cS1pgQn8OeDg4qSBf9tZ1C8gSErwegg="><script defer src="/javascript/fontawesome.min.be83f86daeb960ece02aec3f9b5915b790b371ffca334c3023d911997e2139f6.js" integrity="sha256-voP4ba65YOzgKuw/m1kVt5Czcf/KM0wwI9kRmX4hOfY="></script><link href=http://gmpg.org/xfn/11 rel=profile><meta name=generator content="Hugo 0.143.1"></head></html><body class="min-h-full max-w-4xl font-sans mx-4 lg:mx-auto xl:mx-auto leading-normal my-8"><header class="mx-auto pb-4"><h1 class="text-center lg:text-left text-4xl text-gray-900 font-medium m-0"><a class=text-gray-900 href=/>Nick Karpov</a></h1><div class="lg:flex text-center justify-between"><p class="text-lg text-gray-600">llms killed my best friend</p><nav class=my-auto><ul class="justify-center flex flex-wrap list-disc list-inside"><li class="list-none mx-2"><a class=text-gray-600 href=/index.xml><i class="text-2xl fas fa-rss"></i></a></li><li class="list-none mx-2"><a class=text-gray-600 href=https://x.com/nickkarpov><i class="text-2xl fas fa-twitter"></i></a></li></ul></nav></div><nav class="text-center border-t border-b px-1 mt-4"><ul class="list-disc list-inside"><li class="inline-block list-none mx-4"><a href=/about>About</a></li><li class="inline-block list-none mx-4"><a href=/archives/>Archives</a></li><li class="inline-block list-none mx-4"><a href=/categories/>Categories</a></li><li class="inline-block list-none mx-4"><a href=/tags/>Tags</a></li></ul></nav></header><main class="flex-1 text-gray-900"><article class="container pt-8"><header class="pb-4 mb-8 border-b"><h1 class="my-2 text-black leading-tight">RIP flatMapGroupsWithState</h1></header><div class=post-content><p>The new <code>transformWithState</code> API is now available on <a href=https://www.databricks.com/blog/introducing-transformwithstate-apache-sparktm-structured-streaming>Databricks Runtime 16.2</a> and you'd be crazy not to <a href=https://docs.databricks.com/aws/en/stateful-applications/>try it</a>.</p><p>The improvements over the old <code>flatMapGroupsWithState</code> and <code>applyInPandasWithState</code> approaches to handling custom state are compelling from an API perspective and <strong>a total no brainer for performance</strong>.</p><p>Here's a stab at migrating a simple PySpark Streaming job to use <code>transformWithState</code> with some inline commentary that highlight the relevant API improvements and performance implications.</p><h2 id=why-applyinpandaswithstate-and-flatmapgroupswithstate-suck>Why applyInPandasWithState and flatMapGroupsWithState suck</h2><p>Here's a simple streaming operator written with the old <code>applyInPandasWithState</code> API. It's job is to aggregate events for a fleet of delivery vehicles and write them out to a table only when the vehicle sends a <code>delivered</code> event.</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#60a0b0;font-style:italic># our aggregating function that takes:</span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>#    - key (grouping key)</span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>#    - pdf_iter (rows that belong to the key)</span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>#    - state (arbitrary state object for the key)</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>stateful_accumulate</span>(key, pdf_iter, state: GroupState):
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> state<span style=color:#666>.</span>exists:
</span></span><span style=display:flex><span>        stored_tuple <span style=color:#666>=</span> state<span style=color:#666>.</span>get
</span></span><span style=display:flex><span>        current_events <span style=color:#666>=</span> stored_tuple[<span style=color:#40a070>0</span>] <span style=color:#007020;font-weight:700>if</span> stored_tuple[<span style=color:#40a070>0</span>] <span style=color:#007020;font-weight:700>else</span> []
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>else</span>:
</span></span><span style=display:flex><span>        current_events <span style=color:#666>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>for</span> pdf <span style=color:#007020;font-weight:700>in</span> pdf_iter:
</span></span><span style=display:flex><span>        current_events<span style=color:#666>.</span>extend(pdf<span style=color:#666>.</span>to_dict(<span style=color:#4070a0>&#34;records&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> <span style=color:#007020>any</span>(e[<span style=color:#4070a0>&#34;type&#34;</span>] <span style=color:#666>==</span> <span style=color:#4070a0>&#34;delivered&#34;</span> <span style=color:#007020;font-weight:700>for</span> e <span style=color:#007020;font-weight:700>in</span> current_events):
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>yield</span> pd<span style=color:#666>.</span>DataFrame([{
</span></span><span style=display:flex><span>            <span style=color:#4070a0>&#34;orderid&#34;</span>: key[<span style=color:#40a070>0</span>],
</span></span><span style=display:flex><span>            <span style=color:#4070a0>&#34;events&#34;</span>:  current_events
</span></span><span style=display:flex><span>        }])
</span></span><span style=display:flex><span>        state<span style=color:#666>.</span>remove()
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>else</span>:
</span></span><span style=display:flex><span>        state<span style=color:#666>.</span>update((current_events,))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic># we read from an append only table</span>
</span></span><span style=display:flex><span>df <span style=color:#666>=</span> spark<span style=color:#666>.</span>readStream<span style=color:#666>.</span>table(<span style=color:#4070a0>&#34;orders.default.events&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic># define our stream to group by orderid and apply the above stateful_accumulate function</span>
</span></span><span style=display:flex><span>aggregateFleetEvents <span style=color:#666>=</span> df<span style=color:#666>.</span>groupBy(<span style=color:#4070a0>&#34;orderid&#34;</span>)<span style=color:#666>.</span>applyInPandasWithState(
</span></span><span style=display:flex><span>    func<span style=color:#666>=</span>stateful_accumulate,
</span></span><span style=display:flex><span>    outputStructType<span style=color:#666>=</span>output_schema,
</span></span><span style=display:flex><span>    stateStructType<span style=color:#666>=</span>state_schema,
</span></span><span style=display:flex><span>    outputMode<span style=color:#666>=</span><span style=color:#4070a0>&#34;append&#34;</span>,
</span></span><span style=display:flex><span>    timeoutConf<span style=color:#666>=</span><span style=color:#4070a0>&#34;NoTimeout&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic># flush our stream to the target table</span>
</span></span><span style=display:flex><span>aggregateFleetEvents<span style=color:#666>.</span>writeStream<span style=color:#666>.</span>toTable(<span style=color:#4070a0>&#34;orders.default.drives&#34;</span>)
</span></span></code></pre></div><p>The logic in <code>stateful_accumulate</code> works fine, but there are some issues...</p><h3 id=no-explicit-state-lifecycle-management>No explicit state lifecycle management</h3><p>The first issue is that we have no state lifecycle separation. The first few lines are mostly concerned with correctly initializing the state object because it's <em>undefined to start</em>. This looks tolerable for such a simple job but if this was even a little bit more complex the initialization would be a major sore (imagine migrating a job with existing state).</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> state<span style=color:#666>.</span>exists:
</span></span><span style=display:flex><span>    stored_tuple <span style=color:#666>=</span> state<span style=color:#666>.</span>get
</span></span><span style=display:flex><span>    current_events <span style=color:#666>=</span> stored_tuple[<span style=color:#40a070>0</span>] <span style=color:#007020;font-weight:700>if</span> stored_tuple[<span style=color:#40a070>0</span>] <span style=color:#007020;font-weight:700>else</span> []
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>else</span>:
</span></span><span style=display:flex><span>    current_events <span style=color:#666>=</span> []
</span></span></code></pre></div><h3 id=single-state-object>Single state object</h3><p>The second issue is that we have to handle the entire state object at once <em>and</em> rewrite it entirely. This is subtle for small jobs, but a complete deal breaker if you need to scale. Rewriting the entire state every time new events appear simply doesn't make any sense, especially once we need to track multiple logical states per key.</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#60a0b0;font-style:italic># add new events to `current_events`</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>for</span> pdf <span style=color:#007020;font-weight:700>in</span> pdf_iter:
</span></span><span style=display:flex><span>    current_events<span style=color:#666>.</span>extend(pdf<span style=color:#666>.</span>to_dict(<span style=color:#4070a0>&#34;records&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic># ...now current_events = old state + new state</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> <span style=color:#007020>any</span>(e[<span style=color:#4070a0>&#34;type&#34;</span>] <span style=color:#666>==</span> <span style=color:#4070a0>&#34;delivered&#34;</span> <span style=color:#007020;font-weight:700>for</span> e <span style=color:#007020;font-weight:700>in</span> current_events):
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>yield</span> pd<span style=color:#666>.</span>DataFrame([{
</span></span><span style=display:flex><span>        <span style=color:#4070a0>&#34;orderid&#34;</span>: key[<span style=color:#40a070>0</span>],
</span></span><span style=display:flex><span>        <span style=color:#4070a0>&#34;events&#34;</span>:  current_events
</span></span><span style=display:flex><span>    }])
</span></span><span style=display:flex><span>    state<span style=color:#666>.</span>remove()
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>else</span>:
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic># &#39;update&#39; the state aka overwrite the ENTIRE state X_X</span>
</span></span><span style=display:flex><span>    state<span style=color:#666>.</span>update((current_events,))
</span></span></code></pre></div><h2 id=why-transformwithstate-is-better-than-flatmapgroupswithstate-and-applyinpandaswithstate>Why <code>transformWithState</code> is better than <code>flatMapGroupsWithState</code> and <code>applyInPandasWithState</code></h2><p>Here's the same job rewritten to use <code>transformWithState</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#007020;font-weight:700>class</span> <span style=color:#0e84b5;font-weight:700>DeliveryFleetEventAggregator</span>(StatefulProcessor):
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>init</span>(self, handle: StatefulProcessorHandle) <span style=color:#666>-&gt;</span> <span style=color:#007020;font-weight:700>None</span>:
</span></span><span style=display:flex><span>        self<span style=color:#666>.</span>list_state <span style=color:#666>=</span> handle<span style=color:#666>.</span>getListState(stateName<span style=color:#666>=</span><span style=color:#4070a0>&#34;listState&#34;</span>, schema<span style=color:#666>=</span>event_struct)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>handleInputRows</span>(self, key, rows, timerValues) <span style=color:#666>-&gt;</span> Iterator[pd<span style=color:#666>.</span>DataFrame]:
</span></span><span style=display:flex><span>        should_flush <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>for</span> pdf <span style=color:#007020;font-weight:700>in</span> rows:
</span></span><span style=display:flex><span>            self<span style=color:#666>.</span>list_state<span style=color:#666>.</span>appendList(pdf)
</span></span><span style=display:flex><span>            <span style=color:#007020;font-weight:700>if</span> <span style=color:#4070a0>&#39;delivered&#39;</span> <span style=color:#007020;font-weight:700>in</span> pdf[<span style=color:#4070a0>&#39;type&#39;</span>]<span style=color:#666>.</span>values:
</span></span><span style=display:flex><span>                should_flush <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> should_flush:
</span></span><span style=display:flex><span>            <span style=color:#007020;font-weight:700>yield</span> pd<span style=color:#666>.</span>DataFrame([{
</span></span><span style=display:flex><span>                <span style=color:#4070a0>&#34;orderid&#34;</span>: key[<span style=color:#40a070>0</span>],
</span></span><span style=display:flex><span>                <span style=color:#4070a0>&#34;events&#34;</span>:  <span style=color:#007020>list</span>(self<span style=color:#666>.</span>list_state<span style=color:#666>.</span>get())
</span></span><span style=display:flex><span>            }])
</span></span><span style=display:flex><span>            self<span style=color:#666>.</span>list_state<span style=color:#666>.</span>clear()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>close</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#007020>super</span>()<span style=color:#666>.</span>close()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>aggregateFleetEvents <span style=color:#666>=</span> df<span style=color:#666>.</span>groupBy(<span style=color:#4070a0>&#34;orderid&#34;</span>)<span style=color:#666>.</span>transformWithStateInPandas(
</span></span><span style=display:flex><span>    statefulProcessor<span style=color:#666>=</span>DeliveryFleetEventAggregator(),
</span></span><span style=display:flex><span>    outputStructType<span style=color:#666>=</span>output_schema,
</span></span><span style=display:flex><span>    outputMode<span style=color:#666>=</span><span style=color:#4070a0>&#34;append&#34;</span>,
</span></span><span style=display:flex><span>    timeMode<span style=color:#666>=</span><span style=color:#4070a0>&#34;none&#34;</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Lifecycle methods <code>init</code> and <code>close</code> separate setup and teardown concerns from the main processing logic. This is a major improvement in terms of readability and maintainability.</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>init</span>(self, handle: StatefulProcessorHandle) <span style=color:#666>-&gt;</span> <span style=color:#007020;font-weight:700>None</span>:
</span></span><span style=display:flex><span>    self<span style=color:#666>.</span>list_state <span style=color:#666>=</span> handle<span style=color:#666>.</span>getListState(stateName<span style=color:#666>=</span><span style=color:#4070a0>&#34;listState&#34;</span>, schema<span style=color:#666>=</span>event_struct)
</span></span></code></pre></div><p>We have a separate logical state <code>self.list_state</code> that we initialize with <code>handle.getListState</code>. This is part of the new composite types capability that also includes <code>ValueState</code> and <code>MapState</code>. This apparently small difference has major implications. <a href="https://docs.databricks.com/aws/en/stateful-applications?language=Python#custom-state-types">We can work with multiple separate state objects independently, as needed, <em>and</em> we get a massive performance boost as a consequence.</a> The new version only needs to <code>appendList</code> while taking a single pass over the input rows.</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>handleInputRows</span>(self, key, rows, timerValues) <span style=color:#666>-&gt;</span> Iterator[pd<span style=color:#666>.</span>DataFrame]:
</span></span><span style=display:flex><span>    should_flush <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>for</span> pdf <span style=color:#007020;font-weight:700>in</span> rows:
</span></span><span style=display:flex><span>        self<span style=color:#666>.</span>list_state<span style=color:#666>.</span>appendList(pdf)
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> <span style=color:#4070a0>&#39;delivered&#39;</span> <span style=color:#007020;font-weight:700>in</span> pdf[<span style=color:#4070a0>&#39;type&#39;</span>]<span style=color:#666>.</span>values:
</span></span><span style=display:flex><span>            should_flush <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> should_flush:
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>yield</span> pd<span style=color:#666>.</span>DataFrame([{
</span></span><span style=display:flex><span>            <span style=color:#4070a0>&#34;orderid&#34;</span>: key[<span style=color:#40a070>0</span>],
</span></span><span style=display:flex><span>            <span style=color:#4070a0>&#34;events&#34;</span>:  <span style=color:#007020>list</span>(self<span style=color:#666>.</span>list_state<span style=color:#666>.</span>get())
</span></span><span style=display:flex><span>        }])
</span></span><span style=display:flex><span>        self<span style=color:#666>.</span>list_state<span style=color:#666>.</span>clear()
</span></span></code></pre></div><p>We don't have any complex timing or expiration needs in this simple job but <code>transformWithState</code> supports some awesome features like defining timers for custom logic and setting TTL for automatic state eviction, giving you <a href=https://docs.databricks.com/aws/en/stateful-applications/#program-timed-events>fine-grained control over how and when your state data is updated or removed.</a>.</p><p>You'd be crazy not to seriously consider rewriting your old jobs with this new API.</p></div><div class="text-center pt-4 grid grid-cols-12"></div><hr class="border-gray-200 mt-10 mb-4"><div class=giscus></div><script src=https://giscus.app/client.js data-repo=Xuanwo/blog data-repo-id="MDEwOlJlcG9zaXRvcnkyMDYwNzE1Nw==" data-category=Announcements data-category-id=DIC_kwDOATpwtc4B-a6u data-mapping=title data-reactions-enabled=1 data-emit-metadata=0 data-theme=light crossorigin=anonymous async></script></article></main></body></html>