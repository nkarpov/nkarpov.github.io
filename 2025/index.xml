<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2025s on Nick Karpov</title><link>https://nickkarpov.com/2025/</link><description>Recent content in 2025s on Nick Karpov</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Wed, 26 Feb 2025 01:00:00 +0000</lastBuildDate><atom:link href="https://nickkarpov.com/2025/index.xml" rel="self" type="application/rss+xml"/><item><title>RIP flatMapGroupsWithState</title><link>https://nickkarpov.com/2025/transform-with-state/</link><pubDate>Wed, 26 Feb 2025 01:00:00 +0000</pubDate><guid>https://nickkarpov.com/2025/transform-with-state/</guid><description>&lt;p>The new &lt;code>transformWithState&lt;/code> API is now available on &lt;a href="https://www.databricks.com/blog/introducing-transformwithstate-apache-sparktm-structured-streaming">Databricks Runtime 16.2&lt;/a> and you'd be crazy not to &lt;a href="https://docs.databricks.com/aws/en/stateful-applications/">try it&lt;/a>.&lt;/p>
&lt;p>The improvements over the old &lt;code>flatMapGroupsWithState&lt;/code> and &lt;code>applyInPandasWithState&lt;/code> approaches to handling custom state are compelling from an API perspective and &lt;strong>a total no brainer for performance&lt;/strong>.&lt;/p>
&lt;p>Here's a stab at migrating a simple PySpark Streaming job to use &lt;code>transformWithState&lt;/code> with some inline commentary that highlight the relevant API improvements and performance implications.&lt;/p>
&lt;h2 id="why-applyinpandaswithstate-and-flatmapgroupswithstate-suck">Why applyInPandasWithState and flatMapGroupsWithState suck&lt;/h2>
&lt;p>Here's a simple streaming operator written with the old &lt;code>applyInPandasWithState&lt;/code> API. It's job is to aggregate events for a fleet of delivery vehicles and write them out to a table only when the vehicle sends a &lt;code>delivered&lt;/code> event.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># our aggregating function that takes:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># - key (grouping key)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># - pdf_iter (rows that belong to the key)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># - state (arbitrary state object for the key)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">stateful_accumulate&lt;/span>(key, pdf_iter, state: GroupState):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> state&lt;span style="color:#666">.&lt;/span>exists:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stored_tuple &lt;span style="color:#666">=&lt;/span> state&lt;span style="color:#666">.&lt;/span>get
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current_events &lt;span style="color:#666">=&lt;/span> stored_tuple[&lt;span style="color:#40a070">0&lt;/span>] &lt;span style="color:#007020;font-weight:bold">if&lt;/span> stored_tuple[&lt;span style="color:#40a070">0&lt;/span>] &lt;span style="color:#007020;font-weight:bold">else&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current_events &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> pdf &lt;span style="color:#007020;font-weight:bold">in&lt;/span> pdf_iter:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current_events&lt;span style="color:#666">.&lt;/span>extend(pdf&lt;span style="color:#666">.&lt;/span>to_dict(&lt;span style="color:#4070a0">&amp;#34;records&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020">any&lt;/span>(e[&lt;span style="color:#4070a0">&amp;#34;type&amp;#34;&lt;/span>] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#34;delivered&amp;#34;&lt;/span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> e &lt;span style="color:#007020;font-weight:bold">in&lt;/span> current_events):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">yield&lt;/span> pd&lt;span style="color:#666">.&lt;/span>DataFrame([{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;orderid&amp;#34;&lt;/span>: key[&lt;span style="color:#40a070">0&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;events&amp;#34;&lt;/span>: current_events
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state&lt;span style="color:#666">.&lt;/span>remove()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state&lt;span style="color:#666">.&lt;/span>update((current_events,))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># we read from an append only table&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>df &lt;span style="color:#666">=&lt;/span> spark&lt;span style="color:#666">.&lt;/span>readStream&lt;span style="color:#666">.&lt;/span>table(&lt;span style="color:#4070a0">&amp;#34;orders.default.events&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># define our stream to group by orderid and apply the above stateful_accumulate function&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>aggregateFleetEvents &lt;span style="color:#666">=&lt;/span> df&lt;span style="color:#666">.&lt;/span>groupBy(&lt;span style="color:#4070a0">&amp;#34;orderid&amp;#34;&lt;/span>)&lt;span style="color:#666">.&lt;/span>applyInPandasWithState(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> func&lt;span style="color:#666">=&lt;/span>stateful_accumulate,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outputStructType&lt;span style="color:#666">=&lt;/span>output_schema,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stateStructType&lt;span style="color:#666">=&lt;/span>state_schema,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outputMode&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#4070a0">&amp;#34;append&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> timeoutConf&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#4070a0">&amp;#34;NoTimeout&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># flush our stream to the target table&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>aggregateFleetEvents&lt;span style="color:#666">.&lt;/span>writeStream&lt;span style="color:#666">.&lt;/span>toTable(&lt;span style="color:#4070a0">&amp;#34;orders.default.drives&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The logic in &lt;code>stateful_accumulate&lt;/code> works fine, but there are some issues...&lt;/p>
&lt;h3 id="no-explicit-state-lifecycle-management">No explicit state lifecycle management&lt;/h3>
&lt;p>The first issue is that we have no state lifecycle separation. The first few lines are mostly concerned with correctly initializing the state object because it's &lt;em>undefined to start&lt;/em>. This looks tolerable for such a simple job but if this was even a little bit more complex the initialization would be a major sore (imagine migrating a job with existing state).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">if&lt;/span> state&lt;span style="color:#666">.&lt;/span>exists:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stored_tuple &lt;span style="color:#666">=&lt;/span> state&lt;span style="color:#666">.&lt;/span>get
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current_events &lt;span style="color:#666">=&lt;/span> stored_tuple[&lt;span style="color:#40a070">0&lt;/span>] &lt;span style="color:#007020;font-weight:bold">if&lt;/span> stored_tuple[&lt;span style="color:#40a070">0&lt;/span>] &lt;span style="color:#007020;font-weight:bold">else&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current_events &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="single-state-object">Single state object&lt;/h3>
&lt;p>The second issue is that we have to handle the entire state object at once &lt;em>and&lt;/em> rewrite it entirely. This is subtle for small jobs, but a complete deal breaker if you need to scale. Rewriting the entire state every time new events appear simply doesn't make any sense, especially once we need to track multiple logical states per key.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># add new events to `current_events`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">for&lt;/span> pdf &lt;span style="color:#007020;font-weight:bold">in&lt;/span> pdf_iter:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current_events&lt;span style="color:#666">.&lt;/span>extend(pdf&lt;span style="color:#666">.&lt;/span>to_dict(&lt;span style="color:#4070a0">&amp;#34;records&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># ...now current_events = old state + new state&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020">any&lt;/span>(e[&lt;span style="color:#4070a0">&amp;#34;type&amp;#34;&lt;/span>] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#34;delivered&amp;#34;&lt;/span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> e &lt;span style="color:#007020;font-weight:bold">in&lt;/span> current_events):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">yield&lt;/span> pd&lt;span style="color:#666">.&lt;/span>DataFrame([{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;orderid&amp;#34;&lt;/span>: key[&lt;span style="color:#40a070">0&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;events&amp;#34;&lt;/span>: current_events
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state&lt;span style="color:#666">.&lt;/span>remove()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># &amp;#39;update&amp;#39; the state aka overwrite the ENTIRE state X_X&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state&lt;span style="color:#666">.&lt;/span>update((current_events,))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="why-transformwithstate-is-better-than-flatmapgroupswithstate-and-applyinpandaswithstate">Why &lt;code>transformWithState&lt;/code> is better than &lt;code>flatMapGroupsWithState&lt;/code> and &lt;code>applyInPandasWithState&lt;/code>&lt;/h2>
&lt;p>Here's the same job rewritten to use &lt;code>transformWithState&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">DeliveryFleetEventAggregator&lt;/span>(StatefulProcessor):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">init&lt;/span>(self, handle: StatefulProcessorHandle) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020;font-weight:bold">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>list_state &lt;span style="color:#666">=&lt;/span> handle&lt;span style="color:#666">.&lt;/span>getListState(stateName&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#4070a0">&amp;#34;listState&amp;#34;&lt;/span>, schema&lt;span style="color:#666">=&lt;/span>event_struct)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">handleInputRows&lt;/span>(self, key, rows, timerValues) &lt;span style="color:#666">-&amp;gt;&lt;/span> Iterator[pd&lt;span style="color:#666">.&lt;/span>DataFrame]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> should_flush &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">False&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> pdf &lt;span style="color:#007020;font-weight:bold">in&lt;/span> rows:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>list_state&lt;span style="color:#666">.&lt;/span>appendList(pdf)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#4070a0">&amp;#39;delivered&amp;#39;&lt;/span> &lt;span style="color:#007020;font-weight:bold">in&lt;/span> pdf[&lt;span style="color:#4070a0">&amp;#39;type&amp;#39;&lt;/span>]&lt;span style="color:#666">.&lt;/span>values:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> should_flush &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> should_flush:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">yield&lt;/span> pd&lt;span style="color:#666">.&lt;/span>DataFrame([{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;orderid&amp;#34;&lt;/span>: key[&lt;span style="color:#40a070">0&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;events&amp;#34;&lt;/span>: &lt;span style="color:#007020">list&lt;/span>(self&lt;span style="color:#666">.&lt;/span>list_state&lt;span style="color:#666">.&lt;/span>get())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>list_state&lt;span style="color:#666">.&lt;/span>clear()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">close&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">super&lt;/span>()&lt;span style="color:#666">.&lt;/span>close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>aggregateFleetEvents &lt;span style="color:#666">=&lt;/span> df&lt;span style="color:#666">.&lt;/span>groupBy(&lt;span style="color:#4070a0">&amp;#34;orderid&amp;#34;&lt;/span>)&lt;span style="color:#666">.&lt;/span>transformWithStateInPandas(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> statefulProcessor&lt;span style="color:#666">=&lt;/span>DeliveryFleetEventAggregator(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outputStructType&lt;span style="color:#666">=&lt;/span>output_schema,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outputMode&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#4070a0">&amp;#34;append&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> timeMode&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#4070a0">&amp;#34;none&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lifecycle methods &lt;code>init&lt;/code> and &lt;code>close&lt;/code> separate setup and teardown concerns from the main processing logic. This is a major improvement in terms of readability and maintainability.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">init&lt;/span>(self, handle: StatefulProcessorHandle) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020;font-weight:bold">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>list_state &lt;span style="color:#666">=&lt;/span> handle&lt;span style="color:#666">.&lt;/span>getListState(stateName&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#4070a0">&amp;#34;listState&amp;#34;&lt;/span>, schema&lt;span style="color:#666">=&lt;/span>event_struct)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We have a separate logical state &lt;code>self.list_state&lt;/code> that we initialize with &lt;code>handle.getListState&lt;/code>. This is part of the new composite types capability that also includes &lt;code>ValueState&lt;/code> and &lt;code>MapState&lt;/code>. This apparently small difference has major implications. &lt;a href="https://docs.databricks.com/aws/en/stateful-applications?language=Python#custom-state-types">We can work with multiple separate state objects independently, as needed, &lt;em>and&lt;/em> we get a massive performance boost as a consequence.&lt;/a> The new version only needs to &lt;code>appendList&lt;/code> while taking a single pass over the input rows.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">handleInputRows&lt;/span>(self, key, rows, timerValues) &lt;span style="color:#666">-&amp;gt;&lt;/span> Iterator[pd&lt;span style="color:#666">.&lt;/span>DataFrame]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> should_flush &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">False&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> pdf &lt;span style="color:#007020;font-weight:bold">in&lt;/span> rows:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>list_state&lt;span style="color:#666">.&lt;/span>appendList(pdf)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#4070a0">&amp;#39;delivered&amp;#39;&lt;/span> &lt;span style="color:#007020;font-weight:bold">in&lt;/span> pdf[&lt;span style="color:#4070a0">&amp;#39;type&amp;#39;&lt;/span>]&lt;span style="color:#666">.&lt;/span>values:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> should_flush &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> should_flush:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">yield&lt;/span> pd&lt;span style="color:#666">.&lt;/span>DataFrame([{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;orderid&amp;#34;&lt;/span>: key[&lt;span style="color:#40a070">0&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;events&amp;#34;&lt;/span>: &lt;span style="color:#007020">list&lt;/span>(self&lt;span style="color:#666">.&lt;/span>list_state&lt;span style="color:#666">.&lt;/span>get())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>list_state&lt;span style="color:#666">.&lt;/span>clear()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We don't have any complex timing or expiration needs in this simple job but &lt;code>transformWithState&lt;/code> supports some awesome features like defining timers for custom logic and setting TTL for automatic state eviction, giving you &lt;a href="https://docs.databricks.com/aws/en/stateful-applications/#program-timed-events">fine-grained control over how and when your state data is updated or removed.&lt;/a>.&lt;/p>
&lt;p>You'd be crazy not to seriously consider rewriting your old jobs with this new API.&lt;/p></description></item></channel></rss>